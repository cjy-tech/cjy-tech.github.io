## Github Actions이란?

`Github Actions`이란 Github에서 제공하는 워크플로우(workflow)를 자동화하도록 도와주는 도구이다. 테스트, 빌드, 배포 등의 다양한 작업들을 자동화하여 처리한다.

### 요금과 제한

public 저장소의 경우 무료로 사용가능하며 private 저장소는 월마다 제공되는 무료 사용량 초과 시에 요금이 부과된다. 무료 계정을 기준으로 500MB의 스토리지와 월마다 2,000분의 실행시간이 제공된다.

## Github Actions 시작하기

Github Actions은 Github 저장소에서 등록할 수도 있고 `.github/workflows` 폴더 내에 `.yml` 파일을 추가하여 등록할 수도 있다.

전자의 경우 Github이 해당 저장소에서 사용하는 기술에 맞는 workflow 템플릿을 추천해준다.
![image](https://user-images.githubusercontent.com/33619494/188438531-fd395905-ee1d-4f12-af2e-a3acbbb511b1.png)

<br>
> <span style="color:  #999999;;">tui-image-editor 저장소의 추천 템플릿</span>

## Github Actions의 구성

### 워크 플로우(workflows)

저장소에 추가하는 자동화된 프로세스이다. 하나 이상의 `job`으로 이루어져 있으며 이벤트에 의해 실행된다.

### 이벤트(Events)

워크 플로우를 실행하는 특정 활동이나 규칙이다. 커밋의 push, pull request가 생성되었을 때 뿐만 아니라 [저장소 dispatch event](https://docs.github.com/en/rest/reference/repos#create-a-repository-dispatch-event)를 통해 Github 외부에서 발생하는 활동으로도 이벤트를 발생시킬 수도 있다.
<br>
```
# push나 pull request가 발생할 때 워크 플로우 실행
on: [push, pull_request]
```

또한 `schedule`에 [POSIX cron 문법](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07)으로 스케쥴 이벤트를 발생시킬 수도 있다.
<br>
```
on:
  schedule:
    - cron: '*/15 * * * *'
```

다양한 이벤트에 대한 정보는 [여기](https://docs.github.com/en/actions/reference/events-that-trigger-workflows)에서 확인가능하다.

### 러너(runners)

[Github 액션 러너 애플리케이션](https://github.com/actions/runner)이 설치된 서버이다. Github에서 호스팅하는 러너를 사용할 수도 있고 직접 호스팅할 수도 있다. Github에서 호스팅하는 러너는 Ubuntu Linux, Windows, macOS 환경을 기반으로 하며 워크 플로우의 각 작업은 새로운 가상환경에서 실행된다.

### 작업(jobs)

워크플로우의 기본 단위라고 보면 되며 다시 더 작은 단위인 스텝(step)으로 이루어져 있다.
기본적으로 워크 플로우는 여러 작업을 병렬적으로 실행하며 순차적으로 실행하도록 설정할 수도 있다. 예를 들어 빌드와 테스트 코드의 수행인 두 작업을 순차적으로 실행할 수도 있으며 이 경우에는 빌드 작업이 실패하면 테스트 작업은 실행되지 않는다.

### 스텝(steps)

작업에서 커맨드를 실행하는 독립적인 단위이다. 한 작업(job)의 각 스텝들은 동일한 러너에서 실행되므로 해당 작업의 액션들은 서로 데이터를 공유한다.

### 액션(actions)

워크 플로우의 가장 작은 요소로 직접 만들어 사용할 수도 있고 마켓에 등록된 이미 만들어진 것을 가져와 사용할 수도 있다.

## 워크 플로우 관리

### 민감한 정보 저장

워크 플로우가 비밀번호나 인증서같은 민감한 정보를 사용한다면 Github에 secret으로 저장하여 환경 변수로 사용 가능하다.
<br>
```
jobs:
  example-job:
    runs-on: unbuntu-latest
    steps:
      - name: Retrieve secret
        # 환경변수로 저장하고
        env:
          super_secret: ${{ secrets.SUPERSECRET }}
        # 저장한 환경변수를 활용한다.
        run: |
          example-command "$super_secret"
```

### 의존적인 작업 구성

기본적으로 작업은 병렬적으로 수행된다. 다른 작업이 완전히 끝난 후에 작업을 실행시키고 싶다면 `needs` 키워드를 통해 작업이 의존성을 갖도록 지정하면 된다.
<br>
```
jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: ./setup_server.sh
  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - run: ./build_server.sh
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: ./test_server.sh
```

`needs` 키워드를 통해 build, test 작업이 각각 이전 작업인 setup, build 작업이 끝난 후에 실행되도록 설정했다.

### 빌드 매트릭스 활용하기

워크 플로우가 다양한 OS, 플랫폼, 언어의 여러 조합에서 테스트를 실행하려는 경우 빌드 매트릭스를 활용하면 된다. 빌드 옵션을 배열로 받는 `strategy` 키워드를 사용하면 된다.
<br>
```
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # 다양한 버전의 Node.js를 이용하여 작업을 여러번 실행
        node: [6, 8, 10]
    steps:
      - uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node }}
```

### 종속성 캐싱

GIthub의 러너는 각 작업에서 새로운 환경으로 실행되므로 작업들이 종속성을 재사용하는 경우 파일들을 캐싱하여 성능을 높이면 된다. 캐시를 생성하면 해당 저장소의 모든 워크 플로우에서 사용 가능하다.
<br>
```
jobs:
  example-job:
    steps:
      - name: Cache node modules
        uses: actions/cache@v2
        env:
          cache-name: cache-node-modules
        with:
          # `~/.npm` 디렉토리를 캐시해 성능을 높인다
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
```

## 그래서 어떻게 자동화 했을까?

우선 버전을 업데이트 하는 과정은 개발자가 직접 하는 것이 낫다고 판단하여 유지하기로 했다. 패치 버전을 올릴지, 마이너 버전을 올릴지는 작업한 내용에 따라 달라질 것이고 일정하지 않을 것이다. 물론 이 주기를 맞추거나 다른 방법으로 자동화할 수 있겠지만 오히려 더 많은 제약이 생길 수 있어 비효율적인 작업이라 생각하였다. 또한 명확한 버저닝을 위해 개발자가 직접 수정하기로 하였다.

그 외에 빌드 과정과 npm, cdn, 문서 배포 과정은 Github Action을 통해 자동화하기로 결정하였다. 여기서 한 가지 자동화하지 않은 것이 있는데 배포를 실행하는 기점이다. 예를 들어 태그가 Github 저장소에 반영될 때 또는 마스터 브랜치에 머지될 때 등 특정 상황이 되었을 때 배포가 자동으로 실행되도록 할 수 있을 것이다.

우리는 여러 시나리오 중 어떤 것이 TOAST UI 애플리케이션에 적합할 지 결정해야 했다. 고려한 시나리오는 아래와 같다.

### 배포 과정을 자동 실행하기 위한 기점

* master 브랜치에 머지되었을 때
    * 마스터에 머지되었을 때 자동으로 배포를 실행하는 방법이다. 하지만 현재 TOAST UI 애플리케이션에서 마스터 브랜치는 배포의 기준이 아니며, 작업이 완료된 PR을 마스터 브랜치에 머지하고 있어 적합하지 않았다.
* 별도 배포용 브랜치를 추가하여, 해당 브랜치에 머지되었을 때
    * 배포용 브랜치를 추가하여 해당 브랜치에 머지되었을 때 자동으로 배포를 실행하는 방법이다. 이 경우 메인 애플리케이션이 아닌 [랩퍼 애플리케이션](https://github.com/nhn/tui.editor/tree/master/apps/react-editor)나 [플러그인](https://github.com/nhn/tui.editor/tree/master/plugins)과 같은 프로젝트도 별도 브랜치를 만들어 관리해야 한다. 그렇게 되면 브랜치가 너무 많아질 수 있으며 오히려 다른 관리 이슈가 발생할 수 있다.
* 새로운 태그가 추가되었을 때 배포
    * 새로운 태그가 추가되었을 때 자동으로 배포를 실행하는 방법. 패키지 별로 배포가 될 경우 태그 규칙에 따라 배포 과정을 분기 처리해야 한다. 또한 태그를 잘못 반영한 경우에 문제가 발생할 수 있다.
* 원하는 시점에 실행하기
    * 원하는 패키지를 대상으로 수동으로 배포를 실행하는 방법이다. 직접 배포를 실행해야 하기 때문에 번거로울 수 있으며, 다른 방법과 마찬가지로 패키지 별로 배포할 경우 각각의 배포 스크립트를 따로 작성해야 한다.

결과적으로 간단한 내부 회의를 거쳐 위의 4가지 방법 중 원하는 시점에 실행하기으로 우선 도입하기로 하였다. 이를 위해 모든 액션의 실행 시점을 `workflow_dispatch`로 설정하였다.
<br>
```
# npm 배포 스크립트 일부 예시
name: Npm Publish
on: [workflow_dispatch]
...
```

`workflow_dispatch`는 수동으로 요청을 발생시키는 이벤트로 이를 이용하면 Github 저장소의Actions 탭 내에 manual 버튼을 만들 수 있다. 그리고 이 버튼을 클릭했을 때 특정 workflow를 동작시킬 수 있다. 아래 그림처럼 Run workflow 버튼을 눌러 원하는 workflow를(배포)를 실행할 수 있다.

![image](https://user-images.githubusercontent.com/33619494/188439058-6866d663-0b84-4d8d-9d81-cdb0800d25db.png)


<br>
여러 시나리오가 있었지만 이 방법이 가장 안전하고 실수가 없을 것이라 판단했다. 만약 이 방법이 많이 번거롭다면 추후 다른 자동화 방법을 고려하는 것으로 결정하였다.

### Github Action 적용

그럼 어떤 식으로 Github Action을 적용했는지 간단하게 알아보자.

#### npm 배포 및 태그 생성

```
name: Npm Publish
on: [workflow_dispatch]
jobs:
  checkVersion:
    name: Check package version
    runs-on: ubuntu-latest
    steps:
      # ...
      - name: Cancel when unchanged
        uses: andymckay/cancel-action@0.2
        if: steps.check.outputs.is-new-version == 'false'

  pre-check:
    # ...

  test:
    #...

  plugin-test:
    #...

  publish:
    runs-on: ubuntu-latest
    needs: [pre-check, test, plugin-test]
    steps:
      # ...
      - name: Use Node.js 15.x
        uses: actions/setup-node@v1
        with:
          node-version: '15.x'
          registry-url: https://registry.npmjs.org/
      - name: Install
        run: |
          npm ci
      - name: Build
        run: |
          npm run build toastmark
          npm run build editor
          npm run build react
          npm run build vue
      - name: Create Tag
        run: |
          git config --local user.email '********'
          git config --local user.name '********'
          git tag editor@${{ steps.check.outputs.committed-version }}
      - name: Push Tag
        run: |
          git push origin editor@${{ steps.check.outputs.committed-version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Npm Publish(editor)
        working-directory: ./apps/editor
        run: |
          npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
      - name: Npm Publish(react)
        working-directory: ./apps/react-editor
        run: |
          npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
      - name: Npm Publish(vue)
        working-directory: ./apps/vue-editor
        run: |
          npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
```

위의 스크립트의 실행 과정은 아래와 같다.
<br>
1. 배포를 실행하기 전에 `checkVersion` job에서 실제 npm registry에 배포되어 있는 버전과 현재 패키지의 버전을 비교한다. 만약에 두 버전을 비교했을 때 동일하다면 버전에 변화가 없는 것이기 때문에 이후 작업을 실행하지 않는다.
2. 버전이 다른 것이 확인되었다면 esilnt, 타입 정의 체크, 단위 테스트 등 배포 전에 필요한 회귀 테스트를 실행한다. 만약 이 테스트 중 하나라도 검증에 실패한다면 배포는 실행되지 않는다. 테스트 실행 이후에는 번들 파일 산출을 위한 빌드와 태그 생성 및 푸시 작업을 수행한다.
3. 테스트 실행 이후에는 번들 파일 산출을 위한 빌드와 태그 생성 및 푸시 작업을 수행한다.
4. npm 배포를 실행한다.

npm 배포 시에는 인증을 위해 `env.NODE_AUTH_TOKEN`필드에 npm access 토큰(`secrets.NPM_AUTH_TOKEN`)을 설정해야 한다. 이 토큰은 Github Secrets에 저장했기 때문에 `secrets.NPM_AUTH_TOKEN`로 조회할 수 있다.

Github에서는 토큰 또는 특정 계정 정보처럼 보안상 노출되면 안되는 정보는 Secrets에 넣어 사용하는 것을 권장한다.

(참조 링크: [https://docs.github.com/en/actions/reference/encrypted-secrets](https://docs.github.com/en/actions/reference/encrypted-secrets))

![image](https://user-images.githubusercontent.com/33619494/188439188-f7c761b5-3c63-4330-93b9-faa40a636813.png)